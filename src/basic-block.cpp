///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// File: basic-block.cpp
//
// This file implements BasicBlock, defined in basic_block.h
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include "basic-block.h"
#include "instructions.h"
#include "types.h"

using namespace Helix;

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

BasicBlock* BasicBlock::Create(const char* name)
{
	BasicBlock* bb = new BasicBlock();
	bb->Name = name;
	return bb;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

BasicBlock* BasicBlock::Create()
{
	return BasicBlock::Create(nullptr);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool BasicBlock::CanDelete() const
{
	return GetCountUses() == 0 && Instructions.empty();
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void BasicBlock::Destroy(BasicBlock* bb)
{
	helix_assert(bb->BranchTarget.GetCountUses() == 0, "Cannot delete BB, outstanding uses");
	helix_assert(bb->Instructions.empty(), "Cannot delete BB, it's not empty");
	
	delete bb;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

BasicBlock::BasicBlock()
	: BranchTarget(this)
{ }

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

BasicBlock::iterator BasicBlock::InsertBefore(iterator where, Instruction* insn)
{
	return Instructions.insert_before(where, insn);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

BasicBlock::iterator BasicBlock::InsertAfter(iterator where, Instruction* insn)
{
	return Instructions.insert_after(where, insn);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool BasicBlock::HasTerminator() const
{
	if (Instructions.empty())
		return false;

	const Instruction& insn = Instructions.back();
	return Helix::IsTerminator(insn.GetOpcode());
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
