#include "instructions.h"
#include "basic-block.h"

using namespace Helix;

LoadEffectiveAddressInsn* Helix::CreateLoadEffectiveAddress(const Type* baseType, Value* input, Value* index, Value* outputPtr)
{
	return new LoadEffectiveAddressInsn(baseType, input, index, outputPtr);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

CallInsn* Helix::CreateCall(FunctionDef* fn, const ParameterList& params)
{
	return new CallInsn(fn, UndefValue::Get(fn->GetReturnType()), params);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

CallInsn* Helix::CreateCall(FunctionDef* fn, Value* returnValue, const ParameterList& params)
{
	return new CallInsn(fn, returnValue, params);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

CompareInsn* Helix::CreateCompare(Opcode cmpOpcode, Value* lhs, Value* rhs, Value* result)
{
	return new CompareInsn(cmpOpcode, lhs, rhs, result);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

BinOpInsn* Helix::CreateBinOp(Opcode opcode, Value* lhs, Value* rhs, Value* result)
{
	return new BinOpInsn(opcode, lhs, rhs, result);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

UnconditionalBranchInsn* Helix::CreateUnconditionalBranch(BasicBlock* bb)
{
	return new UnconditionalBranchInsn(bb);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

ConditionalBranchInsn* Helix::CreateConditionalBranch(BasicBlock* trueBB, BasicBlock* falseBB, Value* cond)
{
	return new ConditionalBranchInsn(trueBB, falseBB, cond);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

StoreInsn* Helix::CreateStore(Value* src, Value* dst)
{
	return new StoreInsn(src, dst);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

LoadInsn* Helix::CreateLoad(Value* src, Value* dst)
{
	return new LoadInsn(src, dst);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

StackAllocInsn* Helix::CreateStackAlloc(Value* dst, const Type* type, size_t count)
{
	return new StackAllocInsn(dst, type, count);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

RetInsn* Helix::CreateRet()
{
	return new RetInsn();
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

RetInsn* Helix::CreateRet(Value* value)
{
	return new RetInsn(value);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void Instruction::SetOperand(size_t index, Value* value)
{
	helix_assert(index < UINT16_MAX, "index too big");

	if (m_Operands[index] != nullptr) {
		m_Operands[index]->RemoveUse(this, (uint16_t) index);
	}

	m_Operands[index] = value;
	value->AddUse(this, (uint16_t) index);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

ConditionalBranchInsn::ConditionalBranchInsn(BasicBlock* trueBB, BasicBlock* falseBB, Value* cond)
	: Instruction(kInsn_Cbr, 3)
{
	this->SetOperand(0, trueBB->GetBranchTarget());
	this->SetOperand(1, falseBB->GetBranchTarget());
	this->SetOperand(2, cond);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

UnconditionalBranchInsn::UnconditionalBranchInsn(BasicBlock* bb)
	: Instruction(kInsn_Br, 1)
{
	m_Operands[0] = bb->GetBranchTarget();
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

BinOpInsn::BinOpInsn(Opcode opcode, Value* lhs, Value* rhs, Value* result)
	: Instruction(opcode, 3)
{
	m_Operands[0] = lhs;
	m_Operands[1] = rhs;
	m_Operands[2] = result;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

StoreInsn::StoreInsn(Value* src, Value* dst)
	: Instruction(kInsn_Store, 2)
{
	m_Operands[0] = src;
	m_Operands[1] = dst;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

LoadInsn::LoadInsn(Value* src, Value* dst)
	: Instruction(kInsn_Load, 2)
{
	m_Operands[0] = src;
	m_Operands[1] = dst;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

StackAllocInsn::StackAllocInsn(Value* dst, const Type* type, size_t count)
	: Instruction(kInsn_StackAlloc, 1), m_Type(type), m_Count(count)
{
	m_Operands[0] = dst;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

CompareInsn::CompareInsn(Opcode cmpOpcode, Value* lhs, Value* rhs, Value* result)
	: Instruction(cmpOpcode, 3)
{
	this->SetOperand(0, lhs);
	this->SetOperand(1, rhs);
	this->SetOperand(2, result);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

RetInsn::RetInsn(Value* value)
	: Instruction(kInsn_Ret, 1)
{
	this->SetOperand(0, value);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

RetInsn::RetInsn()
	: Instruction(kInsn_Ret, 0)
{ }

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
