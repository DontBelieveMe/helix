#include "basic_block.h"
#include "instructions.h"
#include "types.h"
#include "core.h"

using namespace Helix;

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

BasicBlock* BasicBlock::Create(const char* name)
{
	BasicBlock* bb = new BasicBlock();
	bb->Name = name;
	return bb;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

BasicBlock* BasicBlock::Create()
{
	return BasicBlock::Create(nullptr);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void BasicBlock::Destroy(BasicBlock* bb)
{
	helix_assert(bb->BranchTarget.GetCountUses() == 0);
	helix_assert(bb->Instructions.empty());
	
	delete bb;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

BasicBlock::BasicBlock()
	: BranchTarget(this), Value(kValue_BasicBlock, BuiltinTypes::GetLabelType())
{ }

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

BasicBlock::iterator BasicBlock::InsertBefore(iterator where, Instruction* insn)
{
	return Instructions.insert_before(where, insn);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

BasicBlock::iterator BasicBlock::InsertAfter(iterator where, Instruction* insn)
{
	return Instructions.insert_after(where, insn);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool BasicBlock::HasTerminator() const
{
	if (Instructions.empty())
		return false;

	const Instruction& insn = Instructions.back();
	return Helix::IsTerminator(insn.GetOpcode());
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
