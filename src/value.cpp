#include "value.h"
#include "hash.h"

#include <unordered_map>
#include <algorithm>

using namespace Helix;

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

struct IntegerSignature
{
	const Type* Ty;
	Integer     Value;

	bool operator==(const IntegerSignature& other) const
		{ return Ty == other.Ty && Value == other.Value; }
};

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

namespace std
{
	template <>
	struct hash<IntegerSignature>
	{
		size_t operator()(const IntegerSignature& sig) const
		{
			size_t hash = std::hash<const Type*>()(sig.Ty);
			Helix::hash_combine(hash, std::hash<Integer>()(sig.Value));
			return hash;
		}
	};
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

using IntegerCacheMap = std::unordered_map<IntegerSignature, ConstantInt*>;

static IntegerCacheMap s_IntegerCache;

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool Use::operator==(const Use& other) const
{
	return m_User == other.m_User && m_OperandIndex == other.m_OperandIndex;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

VirtualRegisterName* VirtualRegisterName::Create(const Type* type, const char* name)
{
	VirtualRegisterName* vreg = new VirtualRegisterName(type);
	vreg->m_DebugName = name;
	return vreg;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

VirtualRegisterName* VirtualRegisterName::Create(const Type* type)
{
	return VirtualRegisterName::Create(type, nullptr);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

ConstantInt* ConstantInt::Create(const Type* ty, Integer value)
{
	IntegerCacheMap::iterator it = s_IntegerCache.find({ty, value});

	if (it != s_IntegerCache.end()) {
		return it->second;
	}

	ConstantInt* ci = new ConstantInt(ty);
	ci->m_Integer   = value;

	const IntegerSignature sig { ty, value };
	s_IntegerCache[sig] = ci;

	return ci;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void Value::AddUse(Instruction* user, uint16_t operandIndex)
{
	m_Users.push_back({user, operandIndex});
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void Value::RemoveUse(Instruction* user, uint16_t operandIndex)
{
	m_Users.erase(std::remove(m_Users.begin(), m_Users.end(), Use(user, operandIndex)), m_Users.end());
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
